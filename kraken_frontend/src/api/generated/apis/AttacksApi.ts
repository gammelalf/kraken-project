/* tslint:disable */
/* eslint-disable */
/**
 * kraken
 * The core component of kraken-project
 *
 * The version of the OpenAPI document: 0.4.2
 * Contact: git@omikron.dev
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiErrorResponse,
  BruteforceSubdomainsRequest,
  BruteforceSubdomainsResultsPage,
  DnsResolutionRequest,
  DnsResolutionResultsPage,
  DnsTxtScanRequest,
  DnsTxtScanResultsPage,
  HostAliveResultsPage,
  HostsAliveRequest,
  ListAttacks,
  OsDetectionRequest,
  OsDetectionResultsPage,
  QueryCertificateTransparencyRequest,
  QueryCertificateTransparencyResultsPage,
  QueryDehashedRequest,
  QueryUnhashedResultsPage,
  ServiceDetectionRequest,
  ServiceDetectionResultsPage,
  SimpleAttack,
  UdpServiceDetectionRequest,
  UdpServiceDetectionResultsPage,
  UuidResponse,
} from '../models';
import {
    ApiErrorResponseFromJSON,
    ApiErrorResponseToJSON,
    BruteforceSubdomainsRequestFromJSON,
    BruteforceSubdomainsRequestToJSON,
    BruteforceSubdomainsResultsPageFromJSON,
    BruteforceSubdomainsResultsPageToJSON,
    DnsResolutionRequestFromJSON,
    DnsResolutionRequestToJSON,
    DnsResolutionResultsPageFromJSON,
    DnsResolutionResultsPageToJSON,
    DnsTxtScanRequestFromJSON,
    DnsTxtScanRequestToJSON,
    DnsTxtScanResultsPageFromJSON,
    DnsTxtScanResultsPageToJSON,
    HostAliveResultsPageFromJSON,
    HostAliveResultsPageToJSON,
    HostsAliveRequestFromJSON,
    HostsAliveRequestToJSON,
    ListAttacksFromJSON,
    ListAttacksToJSON,
    OsDetectionRequestFromJSON,
    OsDetectionRequestToJSON,
    OsDetectionResultsPageFromJSON,
    OsDetectionResultsPageToJSON,
    QueryCertificateTransparencyRequestFromJSON,
    QueryCertificateTransparencyRequestToJSON,
    QueryCertificateTransparencyResultsPageFromJSON,
    QueryCertificateTransparencyResultsPageToJSON,
    QueryDehashedRequestFromJSON,
    QueryDehashedRequestToJSON,
    QueryUnhashedResultsPageFromJSON,
    QueryUnhashedResultsPageToJSON,
    ServiceDetectionRequestFromJSON,
    ServiceDetectionRequestToJSON,
    ServiceDetectionResultsPageFromJSON,
    ServiceDetectionResultsPageToJSON,
    SimpleAttackFromJSON,
    SimpleAttackToJSON,
    UdpServiceDetectionRequestFromJSON,
    UdpServiceDetectionRequestToJSON,
    UdpServiceDetectionResultsPageFromJSON,
    UdpServiceDetectionResultsPageToJSON,
    UuidResponseFromJSON,
    UuidResponseToJSON,
} from '../models';

export interface BruteforceSubdomainsOperationRequest {
    bruteforceSubdomainsRequest: BruteforceSubdomainsRequest;
}

export interface DeleteAttackRequest {
    uuid: string;
}

export interface DnsResolutionOperationRequest {
    dnsResolutionRequest: DnsResolutionRequest;
}

export interface DnsTxtScanOperationRequest {
    dnsTxtScanRequest: DnsTxtScanRequest;
}

export interface GetAttackRequest {
    uuid: string;
}

export interface GetBruteforceSubdomainsResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetDnsResolutionResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetDnsTxtScanResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetHostAliveResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetOsDetectionResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetQueryCertificateTransparencyResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetQueryUnhashedResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetServiceDetectionResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetUdpServiceDetectionResultsRequest {
    uuid: string;
    limit: number;
    offset: number;
}

export interface GetWorkspaceAttacksRequest {
    uuid: string;
}

export interface HostsAliveCheckRequest {
    hostsAliveRequest: HostsAliveRequest;
}

export interface OsDetectionOperationRequest {
    osDetectionRequest: OsDetectionRequest;
}

export interface QueryCertificateTransparencyOperationRequest {
    queryCertificateTransparencyRequest: QueryCertificateTransparencyRequest;
}

export interface QueryDehashedOperationRequest {
    queryDehashedRequest: QueryDehashedRequest;
}

export interface ServiceDetectionOperationRequest {
    serviceDetectionRequest: ServiceDetectionRequest;
}

export interface UdpServiceDetectionOperationRequest {
    udpServiceDetectionRequest: UdpServiceDetectionRequest;
}

/**
 * 
 */
export class AttacksApi extends runtime.BaseAPI {

    /**
     * Enumerate possible subdomains by querying a DNS server with constructed domains. See [OWASP](https://owasp.org/www-community/attacks/Brute_force_attack) for further information.
     * Bruteforce subdomains through a DNS wordlist attack
     */
    async bruteforceSubdomainsRaw(requestParameters: BruteforceSubdomainsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.bruteforceSubdomainsRequest === null || requestParameters.bruteforceSubdomainsRequest === undefined) {
            throw new runtime.RequiredError('bruteforceSubdomainsRequest','Required parameter requestParameters.bruteforceSubdomainsRequest was null or undefined when calling bruteforceSubdomains.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/bruteforceSubdomains`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BruteforceSubdomainsRequestToJSON(requestParameters.bruteforceSubdomainsRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Enumerate possible subdomains by querying a DNS server with constructed domains. See [OWASP](https://owasp.org/www-community/attacks/Brute_force_attack) for further information.
     * Bruteforce subdomains through a DNS wordlist attack
     */
    async bruteforceSubdomains(requestParameters: BruteforceSubdomainsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.bruteforceSubdomainsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete an attack and its results
     */
    async deleteAttackRaw(requestParameters: DeleteAttackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling deleteAttack.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete an attack and its results
     */
    async deleteAttack(requestParameters: DeleteAttackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteAttackRaw(requestParameters, initOverrides);
    }

    /**
     * Perform domain name resolution
     */
    async dnsResolutionRaw(requestParameters: DnsResolutionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.dnsResolutionRequest === null || requestParameters.dnsResolutionRequest === undefined) {
            throw new runtime.RequiredError('dnsResolutionRequest','Required parameter requestParameters.dnsResolutionRequest was null or undefined when calling dnsResolution.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/dnsResolution`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DnsResolutionRequestToJSON(requestParameters.dnsResolutionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Perform domain name resolution
     */
    async dnsResolution(requestParameters: DnsResolutionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.dnsResolutionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform DNS TXT scanning & parsing
     */
    async dnsTxtScanRaw(requestParameters: DnsTxtScanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.dnsTxtScanRequest === null || requestParameters.dnsTxtScanRequest === undefined) {
            throw new runtime.RequiredError('dnsTxtScanRequest','Required parameter requestParameters.dnsTxtScanRequest was null or undefined when calling dnsTxtScan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/dnsTxtScan`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: DnsTxtScanRequestToJSON(requestParameters.dnsTxtScanRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Perform DNS TXT scanning & parsing
     */
    async dnsTxtScan(requestParameters: DnsTxtScanOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.dnsTxtScanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve all attacks the user has access to
     */
    async getAllAttacksRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAttacks>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAttacksFromJSON(jsonValue));
    }

    /**
     * Retrieve all attacks the user has access to
     */
    async getAllAttacks(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAttacks> {
        const response = await this.getAllAttacksRaw(initOverrides);
        return await response.value();
    }

    /**
     * Retrieve an attack by id
     */
    async getAttackRaw(requestParameters: GetAttackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SimpleAttack>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getAttack.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SimpleAttackFromJSON(jsonValue));
    }

    /**
     * Retrieve an attack by id
     */
    async getAttack(requestParameters: GetAttackRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SimpleAttack> {
        const response = await this.getAttackRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a bruteforce subdomains\' results by the attack\'s id
     */
    async getBruteforceSubdomainsResultsRaw(requestParameters: GetBruteforceSubdomainsResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BruteforceSubdomainsResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getBruteforceSubdomainsResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getBruteforceSubdomainsResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getBruteforceSubdomainsResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/bruteforceSubdomainsResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BruteforceSubdomainsResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a bruteforce subdomains\' results by the attack\'s id
     */
    async getBruteforceSubdomainsResults(requestParameters: GetBruteforceSubdomainsResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BruteforceSubdomainsResultsPage> {
        const response = await this.getBruteforceSubdomainsResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a dns resolution\'s results by the attack\'s id
     */
    async getDnsResolutionResultsRaw(requestParameters: GetDnsResolutionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DnsResolutionResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getDnsResolutionResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getDnsResolutionResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getDnsResolutionResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/dnsResolutionResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DnsResolutionResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a dns resolution\'s results by the attack\'s id
     */
    async getDnsResolutionResults(requestParameters: GetDnsResolutionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DnsResolutionResultsPage> {
        const response = await this.getDnsResolutionResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a DNS TXT scan\'s results by the attack\'s id
     */
    async getDnsTxtScanResultsRaw(requestParameters: GetDnsTxtScanResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<DnsTxtScanResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getDnsTxtScanResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getDnsTxtScanResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getDnsTxtScanResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/dnsTxtScanResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => DnsTxtScanResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a DNS TXT scan\'s results by the attack\'s id
     */
    async getDnsTxtScanResults(requestParameters: GetDnsTxtScanResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<DnsTxtScanResultsPage> {
        const response = await this.getDnsTxtScanResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a host alive\'s results by the attack\'s id
     */
    async getHostAliveResultsRaw(requestParameters: GetHostAliveResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<HostAliveResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getHostAliveResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getHostAliveResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getHostAliveResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/hostAliveResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => HostAliveResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a host alive\'s results by the attack\'s id
     */
    async getHostAliveResults(requestParameters: GetHostAliveResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<HostAliveResultsPage> {
        const response = await this.getHostAliveResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a host alive\'s results by the attack\'s id
     */
    async getOsDetectionResultsRaw(requestParameters: GetOsDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OsDetectionResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getOsDetectionResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getOsDetectionResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getOsDetectionResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/osDetectionResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OsDetectionResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a host alive\'s results by the attack\'s id
     */
    async getOsDetectionResults(requestParameters: GetOsDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OsDetectionResultsPage> {
        const response = await this.getOsDetectionResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a query certificate transparency\'s results by the attack\'s id
     */
    async getQueryCertificateTransparencyResultsRaw(requestParameters: GetQueryCertificateTransparencyResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryCertificateTransparencyResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getQueryCertificateTransparencyResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getQueryCertificateTransparencyResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getQueryCertificateTransparencyResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/queryCertificateTransparencyResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryCertificateTransparencyResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a query certificate transparency\'s results by the attack\'s id
     */
    async getQueryCertificateTransparencyResults(requestParameters: GetQueryCertificateTransparencyResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryCertificateTransparencyResultsPage> {
        const response = await this.getQueryCertificateTransparencyResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a query dehashed\'s results by the attack\'s id
     */
    async getQueryUnhashedResultsRaw(requestParameters: GetQueryUnhashedResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<QueryUnhashedResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getQueryUnhashedResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getQueryUnhashedResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getQueryUnhashedResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/queryUnhashedResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => QueryUnhashedResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a query dehashed\'s results by the attack\'s id
     */
    async getQueryUnhashedResults(requestParameters: GetQueryUnhashedResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<QueryUnhashedResultsPage> {
        const response = await this.getQueryUnhashedResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a detect service\'s results by the attack\'s id
     */
    async getServiceDetectionResultsRaw(requestParameters: GetServiceDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ServiceDetectionResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getServiceDetectionResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getServiceDetectionResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getServiceDetectionResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/serviceDetectionResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ServiceDetectionResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve a detect service\'s results by the attack\'s id
     */
    async getServiceDetectionResults(requestParameters: GetServiceDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ServiceDetectionResultsPage> {
        const response = await this.getServiceDetectionResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve UDP service detection results by the attack\'s id
     */
    async getUdpServiceDetectionResultsRaw(requestParameters: GetUdpServiceDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UdpServiceDetectionResultsPage>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getUdpServiceDetectionResults.');
        }

        if (requestParameters.limit === null || requestParameters.limit === undefined) {
            throw new runtime.RequiredError('limit','Required parameter requestParameters.limit was null or undefined when calling getUdpServiceDetectionResults.');
        }

        if (requestParameters.offset === null || requestParameters.offset === undefined) {
            throw new runtime.RequiredError('offset','Required parameter requestParameters.offset was null or undefined when calling getUdpServiceDetectionResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.offset !== undefined) {
            queryParameters['offset'] = requestParameters.offset;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/attacks/{uuid}/udpServiceDetectionResults`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UdpServiceDetectionResultsPageFromJSON(jsonValue));
    }

    /**
     * Retrieve UDP service detection results by the attack\'s id
     */
    async getUdpServiceDetectionResults(requestParameters: GetUdpServiceDetectionResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UdpServiceDetectionResultsPage> {
        const response = await this.getUdpServiceDetectionResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Query all attacks of a workspace
     */
    async getWorkspaceAttacksRaw(requestParameters: GetWorkspaceAttacksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListAttacks>> {
        if (requestParameters.uuid === null || requestParameters.uuid === undefined) {
            throw new runtime.RequiredError('uuid','Required parameter requestParameters.uuid was null or undefined when calling getWorkspaceAttacks.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/api/v1/workspaces/{uuid}/attacks`.replace(`{${"uuid"}}`, encodeURIComponent(String(requestParameters.uuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListAttacksFromJSON(jsonValue));
    }

    /**
     * Query all attacks of a workspace
     */
    async getWorkspaceAttacks(requestParameters: GetWorkspaceAttacksRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListAttacks> {
        const response = await this.getWorkspaceAttacksRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Just an ICMP scan for now to see which targets respond.  All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.
     * Check if hosts are reachable
     */
    async hostsAliveCheckRaw(requestParameters: HostsAliveCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.hostsAliveRequest === null || requestParameters.hostsAliveRequest === undefined) {
            throw new runtime.RequiredError('hostsAliveRequest','Required parameter requestParameters.hostsAliveRequest was null or undefined when calling hostsAliveCheck.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/hostsAlive`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: HostsAliveRequestToJSON(requestParameters.hostsAliveRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Just an ICMP scan for now to see which targets respond.  All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.
     * Check if hosts are reachable
     */
    async hostsAliveCheck(requestParameters: HostsAliveCheckRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.hostsAliveCheckRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Tries to find out the operating system of the remote host.
     */
    async osDetectionRaw(requestParameters: OsDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.osDetectionRequest === null || requestParameters.osDetectionRequest === undefined) {
            throw new runtime.RequiredError('osDetectionRequest','Required parameter requestParameters.osDetectionRequest was null or undefined when calling osDetection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/osDetection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OsDetectionRequestToJSON(requestParameters.osDetectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Tries to find out the operating system of the remote host.
     */
    async osDetection(requestParameters: OsDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.osDetectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * For further information, see [the explanation](https://certificate.transparency.dev/).  Certificate transparency can be used to find subdomains or related domains.  `retry_interval` is specified in milliseconds.
     * Query a certificate transparency log collector.
     */
    async queryCertificateTransparencyRaw(requestParameters: QueryCertificateTransparencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.queryCertificateTransparencyRequest === null || requestParameters.queryCertificateTransparencyRequest === undefined) {
            throw new runtime.RequiredError('queryCertificateTransparencyRequest','Required parameter requestParameters.queryCertificateTransparencyRequest was null or undefined when calling queryCertificateTransparency.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/queryCertificateTransparency`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryCertificateTransparencyRequestToJSON(requestParameters.queryCertificateTransparencyRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * For further information, see [the explanation](https://certificate.transparency.dev/).  Certificate transparency can be used to find subdomains or related domains.  `retry_interval` is specified in milliseconds.
     * Query a certificate transparency log collector.
     */
    async queryCertificateTransparency(requestParameters: QueryCertificateTransparencyOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.queryCertificateTransparencyRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * It provides email, password, credit cards and other types of information from leak-databases.  Note that you are only able to query the API if you have bought access and have a running subscription saved in kraken.
     * Query the [dehashed](https://dehashed.com/) API.
     */
    async queryDehashedRaw(requestParameters: QueryDehashedOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.queryDehashedRequest === null || requestParameters.queryDehashedRequest === undefined) {
            throw new runtime.RequiredError('queryDehashedRequest','Required parameter requestParameters.queryDehashedRequest was null or undefined when calling queryDehashed.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/queryDehashed`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: QueryDehashedRequestToJSON(requestParameters.queryDehashedRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * It provides email, password, credit cards and other types of information from leak-databases.  Note that you are only able to query the API if you have bought access and have a running subscription saved in kraken.
     * Query the [dehashed](https://dehashed.com/) API.
     */
    async queryDehashed(requestParameters: QueryDehashedOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.queryDehashedRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Perform service detection on a ip and port combination
     */
    async serviceDetectionRaw(requestParameters: ServiceDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.serviceDetectionRequest === null || requestParameters.serviceDetectionRequest === undefined) {
            throw new runtime.RequiredError('serviceDetectionRequest','Required parameter requestParameters.serviceDetectionRequest was null or undefined when calling serviceDetection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/serviceDetection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ServiceDetectionRequestToJSON(requestParameters.serviceDetectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * Perform service detection on a ip and port combination
     */
    async serviceDetection(requestParameters: ServiceDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.serviceDetectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.  Set `max_retries` to 0 if you don\'t want to try a port more than 1 time.
     * Perform UDP service detection on an ip on a list of ports.
     */
    async udpServiceDetectionRaw(requestParameters: UdpServiceDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UuidResponse>> {
        if (requestParameters.udpServiceDetectionRequest === null || requestParameters.udpServiceDetectionRequest === undefined) {
            throw new runtime.RequiredError('udpServiceDetectionRequest','Required parameter requestParameters.udpServiceDetectionRequest was null or undefined when calling udpServiceDetection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/api/v1/attacks/udpServiceDetection`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UdpServiceDetectionRequestToJSON(requestParameters.udpServiceDetectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UuidResponseFromJSON(jsonValue));
    }

    /**
     * All intervals are interpreted in milliseconds. E.g. a `timeout` of 3000 means 3 seconds.  Set `max_retries` to 0 if you don\'t want to try a port more than 1 time.
     * Perform UDP service detection on an ip on a list of ports.
     */
    async udpServiceDetection(requestParameters: UdpServiceDetectionOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UuidResponse> {
        const response = await this.udpServiceDetectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
