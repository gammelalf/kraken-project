syntax = "proto3";
package attacks;

import "attacks.shared.proto";

/*
-- BruteforceSubdomain
 */

// Request for starting a bruteforce subdomain attack
message BruteforceSubdomainRequest {
  // A unique id that identifies the attack
  string attack_uuid = 1;
  // The domain to use as base name. It shouldn't end in a . like DNS names.
  string domain = 2;
  // Path to a wordlist that can be used for subdomain enumeration.
  //
  // The entries in the wordlist are assumed to be line seperated.
  string wordlist_path = 3;
  // Maximum of concurrent tasks that should be spawned
  //
  // 0 means, that there should be no limit.
  uint32 concurrent_limit = 4;
}

// Response streamed by an bruteforce subdomain attack
message BruteforceSubdomainResponse {
  // Found record
  shared.DNSRecord record = 1;
}

/*
-- TcpPortScan
 */

// Request for starting a tcp port scan attack
message TcpPortScanRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The ip addresses / networks to scan
  repeated attacks.shared.NetOrAddress targets = 2;
  // List of single ports and port ranges
  //
  // If no values are supplied, 1-65535 is used as default
  repeated PortOrRange ports = 3;
  // The time to wait until a connection is considered failed.
  //
  // The timeout is specified in milliseconds.
  uint64 timeout = 4;
  // The concurrent task limit
  uint32 concurrent_limit = 5;
  // The number of times the connection should be retried if it failed.
  uint32 max_retries = 6;
  // The interval that should be wait between retries on a port.
  //
  // The interval is specified in milliseconds.
  uint64 retry_interval = 7;
  // Skips the initial icmp check.
  //
  // All hosts are assumed to be reachable
  bool skip_icmp_check = 8;
}

// An (inclusive) range of ports
message PortRange {
  // The first port number in this range
  uint32 start = 1;
  // The last port number in this range
  uint32 end = 2;
}

// Either a single port or a range of them
message PortOrRange {
  // Workaround field to store a `oneof`
  oneof port_or_range {
    // A single port
    uint32 single = 1;

    // An (inclusive) range of ports
    PortRange range = 2;
  }
}

// Response streamed by an tcp port scan attack
message TcpPortScanResponse {
  // Address
  attacks.shared.Address address = 1;
  // Port value
  uint32 port = 2;
}

/*
--- Certificate Transparency
 */

// Certificate transparency request
message CertificateTransparencyRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The target domain to query
  string target = 2;
  // Also include already expired certificates
  bool include_expired = 3;
  // The number of times the connection should be retried if it failed.
  uint32 max_retries = 4;
  // The interval to wait in between the retries
  // Specified in milliseconds.
  uint64 retry_interval = 5;
}


// Response to a certificate transparency request
message CertificateTransparencyResponse {
  // List of cert entries
  repeated shared.CertEntry entries = 1;
}

/*
 * Service Detection
 */

// Service detection request
message ServiceDetectionRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The ip address to connect to
  attacks.shared.Address address = 2;
  // The port to connect to
  uint32 port = 3;
  // The interval to wait for a response after connecting and sending an optional payload.
  // Specified in milliseconds.
  uint64 timeout = 4;
}

// Response to a service detection request
message ServiceDetectionResponse {
  // Indicates how many services are given and how they are to be interpreted
  ServiceDetectionResponseType responseType = 1;
  // List of services, the interpretation of this field depends on the `responseType`
  repeated string services = 2;
}

// Indicates how many services are returned in a ServiceDetectionResponse and how they are to be interpreted
enum ServiceDetectionResponseType {
  // The service is unknown
  UNKNOWN = 0;
  // The service might be one of the list
  MAYBE = 1;
  // The service has been identified
  DEFINITELY = 2;
}

/*
 * Hosts alive check
 */

// Request for checking if hosts are alive
message HostsAliveRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The hosts that should be checked
  repeated attacks.shared.NetOrAddress targets = 2;
  // The timeout, specified in milliseconds.
  uint64 timeout = 3;
  // The concurrent task limit
  uint32 concurrent_limit = 4;
}

// Response for checking which hosts are alive
message HostsAliveResponse {
  // the hosts that responded
  attacks.shared.Address host = 1;
}

/*
 * DNS resolution
 */
message DnsResolutionRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The domains to resolve
  repeated string targets = 2;
  // Maximum of concurrent tasks that should be spawned
  //
  // 0 means, that there should be no limit.
  uint32 concurrent_limit = 3;
}

// Response streamed by a dns resolution attack
message DnsResolutionResponse {
  // Found record
  shared.DNSRecord record = 1;
}

/*
 * testssl.sh
 */

// Request for running testssl.sh
message TestSSLRequest {
  // A unique id that identifier the attack
  string attack_uuid = 1;
  // The domain to scan
  string uri = 2;
  // Timeout for TCP handshakes in seconds
  optional uint64 connect_timeout = 3;
  // Timeout for `openssl` connections in seconds
  optional uint64 openssl_timeout = 4;
  // Enable ip v6
  optional bool v6 = 5;
  // Set the `BASICAUTH` header when checking http headers
  optional BasicAuth basic_auth = 6;
  // Run against a STARTTLS enabled protocol
  optional StartTLSProtocol starttls = 7;
  // Which scans `testssl.sh` should run
  optional TestSSLScans scans = 8;
}

// The `BASICAUTH` header
message BasicAuth {
  // The username
  string username = 1;
  // The password
  string password = 2;
}

// Protocols to select from when using `testssl.sh`'s `--starttls` option
enum StartTLSProtocol {
  // FTP
  FTP      = 0;
  // SMTP
  SMTP     = 1;
  // POP3
  POP3     = 2;
  // IMAP
  IMAP     = 3;
  // XMPP
  XMPP     = 4;
  // LMTP
  LMTP     = 5;
  // NNTP
  NNTP     = 6;
  // Postgres
  Postgres = 7;
  // MySQL
  MySQL    = 8;
}

/// Config option which scans `testssl.sh` should run
message TestSSLScans {
  // Workaround field to store a `oneof`
  oneof testssl_scans {
    // Either run all scans or just the default ones
    bool all = 1;

    // Select the scans to run manually
    TestSSLScansManual manual = 2;
  }
}

// Select the scans to run manually
//
// Each field (except `cipher_tests_...`) correspond directly to a section in `testssl.sh`'s output
message TestSSLScansManual {
  /// Enables [`ScanResult`]'s `protocols` section
  bool protocols = 1;

  /// Enables [`ScanResult`]'s `grease` section
  bool grease = 2;

  /// Enables [`ScanResult`]'s `ciphers` section
  bool ciphers = 3;

  /// Enables [`ScanResult`]'s `pfs` section
  bool pfs = 4;

  /// Enables [`ScanResult`]'s `server_preferences` section
  bool server_preferences = 5;

  /// Enables [`ScanResult`]'s `server_defaults` section
  bool server_defaults = 6;

  /// Enables [`ScanResult`]'s `header_response` section
  bool header_response = 7;

  /// Enables [`ScanResult`]'s `vulnerabilities` section
  bool vulnerabilities = 8;

  /// Enables [`ScanResult`]'s `cipher_tests` section
  bool cipher_tests_all = 9;

  /// Enables [`ScanResult`]'s `cipher_tests` section
  bool cipher_tests_per_proto = 10;

  /// Enables [`ScanResult`]'s `browser_simulations` section
  bool browser_simulations = 11;
}

// Response to a test ssl request
message TestSSLResponse {
  // The services' scan results or their errors
  repeated TestSSLService services = 1;
}

// A service's scan results or an error
message TestSSLService {
  // Workaround field to store a `oneof`
  oneof testssl_service {
    // The result from scanning a service
    TestSSLScanResult result = 1;

    // Some error prevented a service from being scanned
    TestSSLFinding error = 2;
  }
}

// A service's scan results
message TestSSLScanResult {
  // The original user target this result belongs to
  string target_host = 1;

  // The scanned ip address
  string ip = 2;

  // The scanned port
  string port = 3;

  // The ip address' rDNS name
  string rdns = 4;

  // The detected service
  string service = 5;

  // TODO: not found yet in the wild
  // optional string hostname = 6;

  // Some sanity checks which can't be disabled
  repeated TestSSLFinding pretest = 7;

  // Which tls protocols are supported
  repeated TestSSLFinding protocols = 8;

  // Server implementation bugs and [GREASE](https://www.ietf.org/archive/id/draft-ietf-tls-grease-01.txt)
  repeated TestSSLFinding grease = 9;

  // Which cipher suites are supported
  repeated TestSSLFinding ciphers = 10;

  // Checks robust (perfect) forward secrecy key exchange
  repeated TestSSLFinding pfs = 11;

  // The server's preferences
  repeated TestSSLFinding server_preferences = 12;

  // The server's defaults
  repeated TestSSLFinding server_defaults = 13;

  // The http header set by the server
  repeated TestSSLFinding header_response = 14;

  // List of several vulnerabilities
  repeated TestSSLFinding vulnerabilities = 15;

  // Which concrete ciphers are supported
  //
  // Depending on the option `testssl` is invoked with,
  // this is either a list of all ciphers or a list of all cipher per tls protocol.
  repeated TestSSLFinding cipher_tests = 16;

  // Which browser is able to establish a connection
  repeated TestSSLFinding browser_simulations = 17;
}

// A single test's result or testssl log message
message TestSSLFinding {
  // The test's id
  string id = 1;
  // The result's severity
  TestSSLSeverity severity = 2;
  // The test's result
  string finding = 3;

  // The associated CVE
  optional string cve = 4;
  // The associated CWE
  optional string cwe = 5;
}

// A TestSSLFinding's severity
enum TestSSLSeverity {
  // A debug level log message
  Debug    = 0;
  // An info level log message
  Info     = 1;
  // A warning level log message
  Warn     = 2;
  // An error level log message
  Fatal    = 3;

  // The test's result doesn't pose an issue
  Ok       = 4;
  // The test's result pose a low priority issue
  Low      = 5;
  // The test's result pose a medium priority issue
  Medium   = 6;
  // The test's result pose a high priority issue
  High     = 7;
  // The test's result pose a critical priority issue
  Critical = 8;
}


// Implemented by leech; allows kraken to request attack from a leech
service ReqAttackService {
  rpc BruteforceSubdomains(BruteforceSubdomainRequest) returns (stream BruteforceSubdomainResponse);
  rpc RunTcpPortScan(TcpPortScanRequest) returns (stream TcpPortScanResponse);
  rpc QueryCertificateTransparency(CertificateTransparencyRequest) returns (CertificateTransparencyResponse);
  rpc ServiceDetection(ServiceDetectionRequest) returns (ServiceDetectionResponse);
  rpc HostsAliveCheck(HostsAliveRequest) returns (stream HostsAliveResponse);
  rpc DnsResolution(DnsResolutionRequest) returns (stream DnsResolutionResponse);
  rpc TestSSL(TestSSLRequest) returns (TestSSLResponse);
}

/*
------------------------ Results -------------------------------
 */

// The response to submitting a result
message ResultResponse {
  // The attack uuid assigned by kraken
  string uuid = 1;
}

// Metainfos about the attack
message MetaAttackInfo {
  // The uuid of a workspace
  string workspace_uuid = 1;

  // The user's api key
  string api_key = 2;
}

// Result of a certificate transparency request
message CertificateTransparencyResult {
  // Information about the attack
  MetaAttackInfo attack_info = 1;
  // List of cert entries
  repeated attacks.shared.CertEntry entries = 2;
}

// Result of a subdomain enumeration request
message SubdomainEnumerationResult {
  // Information about the attack
  MetaAttackInfo attack_info = 1;
  // Found record
  shared.DNSRecord record = 2;
}

// Implemented by kraken; allows leeches to push manual scan results via cli
service AttackResultsService {
  rpc CertificateTransparency(CertificateTransparencyResult) returns (ResultResponse);
  rpc SubdomainEnumeration(stream SubdomainEnumerationResult) returns (ResultResponse);
}


/*
------------------------ Backlog -------------------------------
 */

// Empty response
message EmptyResponse {}

// Dns result (applies to 'bruteforce subdomains' as well as 'dns resolution')
message BacklogDnsResult{
  // the attack that produced the result
  string attack_uuid = 1;
  // the dns record
  shared.DNSRecord record = 2;
}

// multiple dns results
message BacklogDnsRequest {
  /// the results
  repeated BacklogDnsResult entries = 1;
}

// Result of tcp port scan
message BacklogTcpPortScanResult {
  // the attack that produced the result
  string attack_uuid = 1;
  // the ip address
  attacks.shared.Address address = 2;
  // the port
  uint32 port = 3;
}

// multiple tcp port scan results
message BacklogTcpPortScanRequest {
  /// the results
  repeated BacklogTcpPortScanResult entries = 1;
}

// result of host alive check request
message BacklogHostAliveResult {
  // the attack that produced the result
  string attack_uuid = 1;
  // the hosts that responded
  attacks.shared.Address host = 2;
}

// multiple host alive results
message BacklogHostAliveRequest {
  /// the results
  repeated BacklogHostAliveResult entries = 1;
}

// Implemented by kraken; allows leeches to upload results that failed to upload previously
service BacklogService {
  rpc DnsResults(BacklogDnsRequest) returns (EmptyResponse);
  rpc TcpPortScan(BacklogTcpPortScanRequest) returns (EmptyResponse);
  rpc HostAliveCheck(BacklogHostAliveRequest) returns (EmptyResponse);
}