//! Schemas for finding factory shared between API handler and internal code

use std::fmt;
use std::str::FromStr;

use serde::Deserialize;
use serde::Serialize;
use utoipa::ToSchema;

/// Enum identifying specific kinds of issues the finding factory might detect and create findings for.
///
/// TODO: The current variants are plausible dummies
#[derive(Debug, Copy, Clone, Serialize, Deserialize, ToSchema, Eq, PartialEq, Hash)]
pub enum FindingFactoryIdentifier {
    /// Finding generated by testssl, if the target offers the NULL ciphers
    TestSslNullCiphers,
    /// Finding generated by testssl, if the target offers the export ciphers
    TestSslExportCiphers,

    /// Finding generated by service detection, if it detected a postgres
    ServiceDetectionPostgres,
    /// Finding generated by service detection, if it detected a mysql
    ServiceDetectionMySql,

    /// Finding generated by kraken assi, if it detected a leaked certificate
    KrakenAssiCertLeak,
    /// Finding generated by kraken assi, if it found a redirect from https to http
    KrakenAssiConnDowngrade,
    /// Finding generated by kraken assi, if it found a missing HSTS header
    KrakenAssiMissingHSTS,
}

impl FromStr for FindingFactoryIdentifier {
    type Err = serde::de::value::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Self::deserialize(serde::de::value::StrDeserializer::new(s))
    }
}

impl fmt::Display for FindingFactoryIdentifier {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.serialize(f)
    }
}
